import { NextRequest, NextResponse } from 'next/server';
import { getPatch, updatePatchStatus } from '@/lib/dashboard/patch-store';
import { getSession } from '@/lib/auth/session';
import { createPullRequest } from '@/lib/auth/github';

// POST /api/patches/[patchId]/apply - Apply a patch and create a PR
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ patchId: string }> }
) {
  const { patchId } = await params;
  const patch = getPatch(patchId);

  if (!patch) {
    return NextResponse.json({ error: 'Patch not found' }, { status: 404 });
  }

  if (patch.status === 'applied') {
    return NextResponse.json({ error: 'Patch already applied' }, { status: 400 });
  }

  // Get session for GitHub access
  const session = await getSession();

  if (!session || !session.accessToken) {
    return NextResponse.json(
      { error: 'GitHub authentication required' },
      { status: 401 }
    );
  }

  try {
    const body = await request.json().catch(() => ({}));
    const { repoOwner, repoName, baseBranch = 'main' } = body;

    if (!repoOwner || !repoName) {
      return NextResponse.json(
        { error: 'Repository owner and name are required' },
        { status: 400 }
      );
    }

    // In a real implementation, you would:
    // 1. Clone the repo
    // 2. Create a new branch
    // 3. Apply the patch
    // 4. Commit and push
    // 5. Create a PR

    // For now, we'll simulate creating a PR with just the metadata
    const branchName = `patchpilot/fix-${patchId}`;

    const pr = await createPullRequest(session.accessToken, repoOwner, repoName, {
      title: `[PatchPilot] ${patch.description}`,
      body: `## Auto-generated fix by PatchPilot

### Diagnosis
- **Type:** ${patch.diagnosis.type}
- **Confidence:** ${(patch.diagnosis.confidence * 100).toFixed(0)}%
- **Root Cause:** ${patch.diagnosis.rootCause}

### Changes
\`\`\`diff
${patch.diff}
\`\`\`

---
_This PR was automatically generated by [PatchPilot](https://github.com/example/patchpilot)_`,
      head: branchName,
      base: baseBranch,
    });

    // Update patch status
    updatePatchStatus(patchId, 'applied', pr.url);

    return NextResponse.json({
      success: true,
      prUrl: pr.url,
      prNumber: pr.number,
    });
  } catch (error) {
    // eslint-disable-next-line no-console
    console.error('Error applying patch:', error);

    // Check if it's a GitHub API error
    if (error instanceof Error && error.message.includes('GitHub')) {
      return NextResponse.json(
        { error: error.message },
        { status: 422 }
      );
    }

    return NextResponse.json(
      { error: 'Failed to apply patch' },
      { status: 500 }
    );
  }
}
